"use strict";var e=require("../abort-error/index.js"),t=require("../extract-error-message/index.js"),r=require("../is-network-error/index.js"),o=require("../noop/index.js");const{round:n}=Math,i=Error,s=TypeError;function a(e,t,r=0,o=!1){if(Number.isNaN(t))throw new s(`Expected \`${e}\` to be a valid number${o?" or Infinity":""}, got NaN.`);if(!o&&!Number.isFinite(t))throw new s(`Expected \`${e}\` to be a finite number.`);if(t<r)throw new s(`Expected \`${e}\` to be \u2265 ${r}.`)}class c extends i{name="AsyncRetryAbortError";cause;constructor(e){if(super("string"==typeof e?e:t.extractErrorMessage(e,!1)??"Aborted"),"string"==typeof e){const t=new i(e);t.stack=this.stack,this.cause=t}else e instanceof i?(this.cause=e,this.message=e.message):this.cause=e}}async function u(t,o,i,a,u){if(t instanceof c)throw t.cause;if(t instanceof s&&!r.isNetworkError(t)||e.isAbortErrorLike(t))throw t;const m=i.retries-(o-1),f={error:t,attemptNumber:o,retriesLeft:m};await i.onFailedAttempt(f),o>1&&await i.onRetry(t,o-1);const w=Date.now();if(w-a>=u||o>=i.retries+1||!await i.shouldRetry(f))throw t;let h=n((i.randomize?Math.random()+1:1)*i.minTimeout*i.factor**(o-1));h>i.maxTimeout&&(h=i.maxTimeout);const d=u-(w-a);if(d<=0)throw t;let b=h;h>d&&(b=d),b>0&&await new Promise((e,t)=>{const r=setTimeout(()=>{i.signal?.removeEventListener("abort",o),e()},b);function o(){clearTimeout(r),i.signal?.removeEventListener("abort",o),t(i.signal?.reason)}i.unref&&"object"==typeof r&&"unref"in r&&"function"==typeof r.unref&&r.unref(),i.signal?.addEventListener("abort",o,{once:!0})}),i.signal?.throwIfAborted()}function m(e){throw new c(e??"Aborted")}async function f(e,t={}){t.signal?.throwIfAborted();const r={...t};r.retries??=10,r.forever??=!1,r.factor??=2,r.minTimeout??=1e3,r.maxTimeout??=1/0,r.randomize??=!0,r.onFailedAttempt??=o.noop,r.onRetry??=o.noop,r.shouldRetry??=o.trueFn,r.forever&&(r.retries=1/0),a("retries",r.retries,0,!0),a("factor",r.factor,0,!1),a("minTimeout",r.minTimeout,0,!1),a("maxTimeout",r.maxTimeout,0,!0);const n=r.maxRetryTime??1/0;a("maxRetryTime",n,0,!0),r.minTimeout<1&&(r.minTimeout=1),r.factor<=0&&(r.factor=1);let s=0;const w=Date.now();for(;s<r.retries+1;){s++;try{r.signal?.throwIfAborted();const t=await e(m,s);return r.signal?.throwIfAborted(),t}catch(t){let e=t;"object"==typeof t&&t&&"bail"in t&&t.bail&&(e=new c(t)),await u(e,s,r,w,n)}}throw new i("Retry attempts exhausted without throwing an error.")}exports.AsyncRetryAbortError=c,exports.asyncRetry=f,exports.makeRetriable=function(e,t){return function(...r){return f(()=>e.apply(this,r),t)}};