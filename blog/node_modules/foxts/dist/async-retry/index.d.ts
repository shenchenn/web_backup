declare const E: ErrorConstructor;
interface AsyncRetryContext {
    readonly error: unknown;
    readonly attemptNumber: number;
    readonly retriesLeft: number;
}
interface AsyncRetryOptions {
    /**
      Callback invoked on each retry. Receives a context object containing the error and retry state information.
  
      The `onFailedAttempt` function can return a promise. For example, to add extra delay, especially useful reading `Retry-After` header.
  
      If the `onFailedAttempt` function throws, all retries will be aborted and the original promise will reject with the thrown error.
      */
    onFailedAttempt?: (context: AsyncRetryContext) => void | Promise<void>;
    /**
     * @deprecated Use `onFailedAttempt` instead. This is added only to be compatible with `async-retry`
     */
    onRetry?: (error: unknown, attemptNumber: number) => void | Promise<void>;
    /**
      Decide if a retry should occur based on the context. Returning true triggers a retry, false aborts with the error.
  
      It is only called if `retries` and `maxRetryTime` have not been exhausted.
      It is not called for `TypeError` (except network errors) and `AbortError`.
  
      In the example above, the operation will be retried unless the error is an instance of `CustomError`.
      */
    shouldRetry?: (context: AsyncRetryContext) => boolean | Promise<boolean>;
    /**
     * @deprecated Use `retries` w/ `Number.POSITIVE_INFINITY` instead
     */
    forever?: boolean;
    /**
      The maximum amount of times to retry the operation.
      @default 10
      */
    retries?: number;
    /**
      The exponential factor to use.
      @default 2
      */
    factor?: number;
    /**
      The number of milliseconds before starting the first retry.
      @default 1000
      */
    minTimeout?: number;
    /**
      The maximum number of milliseconds between two retries.
      @default Infinity
      */
    maxTimeout?: number;
    /**
      Randomizes the timeouts by multiplying with a factor between 1 and 2.
      @default true
      */
    randomize?: boolean;
    /**
      The maximum time (in milliseconds) that the retried operation is allowed to run.
      @default Infinity
      */
    maxRetryTime?: number;
    /**
      You can abort retrying using [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).
      */
    signal?: AbortSignal;
    /**
      Prevents retry timeouts from keeping the process alive.
      Only affects platforms with a `.unref()` method on timeouts, such as Node.js.
      @default false
      */
    unref?: boolean;
}
declare class AsyncRetryAbortError extends E {
    name: string;
    cause?: unknown;
    constructor(message: string | Error | unknown);
}
declare function asyncRetry<T>(callback: (bail: (reason?: unknown) => void, attemptNumber: number) => PromiseLike<T> | T, retryOptions?: AsyncRetryOptions): Promise<T>;
declare function makeRetriable<Args extends unknown[], Result>(fn: (...args: Args) => PromiseLike<Result> | Result, options?: AsyncRetryOptions): (this: unknown, ...args: Args) => Promise<Result>;

export { AsyncRetryAbortError, asyncRetry, makeRetriable };
export type { AsyncRetryContext, AsyncRetryOptions };
