import{isAbortErrorLike as t}from"../abort-error/index.mjs";import{extractErrorMessage as e}from"../extract-error-message/index.mjs";import{isNetworkError as r}from"../is-network-error/index.mjs";import{noop as o,trueFn as n}from"../noop/index.mjs";const{round:i}=Math,a=Error,s=TypeError;function m(t,e,r=0,o=!1){if(Number.isNaN(e))throw new s(`Expected \`${t}\` to be a valid number${o?" or Infinity":""}, got NaN.`);if(!o&&!Number.isFinite(e))throw new s(`Expected \`${t}\` to be a finite number.`);if(e<r)throw new s(`Expected \`${t}\` to be \u2265 ${r}.`)}class c extends a{name="AsyncRetryAbortError";cause;constructor(t){if(super("string"==typeof t?t:e(t,!1)??"Aborted"),"string"==typeof t){const e=new a(t);e.stack=this.stack,this.cause=e}else t instanceof a?(this.cause=t,this.message=t.message):this.cause=t}}async function f(e,o,n,a,m){if(e instanceof c)throw e.cause;if(e instanceof s&&!r(e)||t(e))throw e;const f=n.retries-(o-1),u={error:e,attemptNumber:o,retriesLeft:f};await n.onFailedAttempt(u),o>1&&await n.onRetry(e,o-1);const w=Date.now();if(w-a>=m||o>=n.retries+1||!await n.shouldRetry(u))throw e;let h=i((n.randomize?Math.random()+1:1)*n.minTimeout*n.factor**(o-1));h>n.maxTimeout&&(h=n.maxTimeout);const d=m-(w-a);if(d<=0)throw e;let b=h;h>d&&(b=d),b>0&&await new Promise((t,e)=>{const r=setTimeout(()=>{n.signal?.removeEventListener("abort",o),t()},b);function o(){clearTimeout(r),n.signal?.removeEventListener("abort",o),e(n.signal?.reason)}n.unref&&"object"==typeof r&&"unref"in r&&"function"==typeof r.unref&&r.unref(),n.signal?.addEventListener("abort",o,{once:!0})}),n.signal?.throwIfAborted()}function u(t){throw new c(t??"Aborted")}async function w(t,e={}){e.signal?.throwIfAborted();const r={...e};r.retries??=10,r.forever??=!1,r.factor??=2,r.minTimeout??=1e3,r.maxTimeout??=1/0,r.randomize??=!0,r.onFailedAttempt??=o,r.onRetry??=o,r.shouldRetry??=n,r.forever&&(r.retries=1/0),m("retries",r.retries,0,!0),m("factor",r.factor,0,!1),m("minTimeout",r.minTimeout,0,!1),m("maxTimeout",r.maxTimeout,0,!0);const i=r.maxRetryTime??1/0;m("maxRetryTime",i,0,!0),r.minTimeout<1&&(r.minTimeout=1),r.factor<=0&&(r.factor=1);let s=0;const h=Date.now();for(;s<r.retries+1;){s++;try{r.signal?.throwIfAborted();const e=await t(u,s);return r.signal?.throwIfAborted(),e}catch(e){let t=e;"object"==typeof e&&e&&"bail"in e&&e.bail&&(t=new c(e)),await f(t,s,r,h,i)}}throw new a("Retry attempts exhausted without throwing an error.")}function h(t,e){return function(...r){return w(()=>t.apply(this,r),e)}}export{c as AsyncRetryAbortError,w as asyncRetry,h as makeRetriable};